\documentclass{article}

\usepackage[utf8]{inputenc} 
\usepackage[russian]{babel}
\usepackage{amsmath,amssymb}
\usepackage{tipa}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage{alltt}
\binoppenalty=10000
\relpenalty=10000
\title{Алгоритмы и Структуры Данных ДЗ-2}
\date{03.05.2020}
\usepackage{multicol}
\usepackage[left=2cm,right=2cm,
    top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}


\author{Гарипов Роман М3138}

\begin{document}


  \pagenumbering{gobble} 
  \maketitle
  \pagenumbering{arabic}

\section*{Задача \textnumero 1}
\subsubsection*{Описание структуры}
Построим дерево отрезков в каждой вершине $v$, отвечающей за отрезок $[tl, tr]$ которого будем хранить матрицу 4 на 4, где $dp[i][j]$ - число способов добраться от $tl + i$ до  $tr - j$ прыгая на одну, две или три клетки. 
\subsection*{Объединяем отрезки}
Чтобы научиться решать задачу, осталось понять, как посчитать значение в вершине, если уже посчитали в левом и правом ребёнке. Для наглядности объясним это кодом :
\begin{alltt}
 1	 // v - vertex
 2	 // [tl, tr] - cur_segment
 3	 // tm = (tl + tr) / 2
 4	 // check_border(x, y) - returns true if exists border on segment [x;y], 
 5 	// we need to check only short segments which length is less or equal than 3,
 6 	// so we can count it as constanty works function
 7    for (int a = 0; a <= 3; a++) \{
 8       for (int b = 0; b <= 3; b++) \{  // a, b - offsets for [tl, tm] - segment
 9           for (int c = 0; c <= 3; c++) \{
10             for (int d = 0; d <= 3; d++) \{  // c, d - offsets for [tm + 1, tr] segment
11                int r = tm + 1 + c;
12                int l = tm - b;
13                if (r - l + 1 <= 3 && !check_border(l, r)) \{
14                   cur_vert_dp[a][d] += dp[a][b] * dp[c][d]
15                \}
16             \}
17          \}
18       \}
19    \}
\end{alltt}
Осталось только понять какие будут начальные значения для вершин соответствующих отрезкам единичной длины. Для них $dp[0][0] = 1$, остальные значения равны 0.
\subsection*{Отвечаем на запросы}
\begin{itemize}
\item Когда просят посчитать число способов на отрезке, спустимся по ДО, как обычно делаем это, когда считаем функцию от отрезка, только будем пересчитывать значения, как это указано выше. Получим матрицу $dp$, ответом на запрос будет $dp[0][0]$.
\item Когда просят добавить перегородку на позицию $x$, спустимся в ДО до вершины, соответсвующей единичному отрезку $[x, x]$ и скажем, что для него $dp$ - нулевая матрица. Так же пометим, что на этом месте находится перегородка, для того чтобы в дальнейщем работала функция \texttt{check\_border}.

Аналогично, когда просят удалить перегородку, ставим в эту вершину матрицу, в которой $dp[0][0] = 1$, остальные - нули. Поднимаемся вверх и пересчитываем значения в вершинах.
\end{itemize}
\textbf{Итого:}
Отвечаем на все запросы за $\mathcal{O}(\log n)$ спуском по ДО.
\section*{Задача \textnumero 3}
\subsection*{Научимся отвечать на такие запросы на префиксе}

Выделим первое вхождение каждого возмножного значения массива. Понятно, что ответом на запрос на префиксе - будет количество отмеченных вершин. Это можно считать деревом отрезков на сумму.
Давайте поймем как отвечать на запросы на отрезке.
\subsection*{А теперь на отрезке}
Посчитаем массив $next[i]$ - индекс ближайшего справа элемента массива, значение которого равно $a[i]$. Тогда, уберем отметку с первого элемента массива, поставим ее на $next[1]$. 
Получили массив отметок для всех отрезков $[1;x], x \in [1;n - 1]$.
Проделаем так, пока не получим массив отметок для всех отрезков.
Для того, чтобы это занимало мало памяти, воспользуемся персистентным деревом отрезоков. А именно - $\mathcal{O}(n \log n)$ памяти, так как каждое изменение массива, будет создавать дополнительную ветку персистентного дерева отрезков.

\textbf{Итого:}
\begin{itemize}
\item Насчитаем массив $next[i]$ и поставим отметки на первое вхождение каждого числа.
\item Для всех возможных правых границ запроса пересчитаем значения в персистентном дереве отрезков
\item Когда приходит запрос \texttt{unique(l, r)} - возьмем версию персистеного дерева отрезков для отрезков начинающихся в \texttt{l}. И вернем сумму на отрезке $[l; r]$ в этой версии дерева отрезков.
\end{itemize}
Получили решение в оффлайне с предпосчётом за $\mathcal{O}(n \log n)$ и ответом на запрос за $\mathcal{O}(\log n)$.
\section*{Задача \textnumero 4}
\subsection*{Идея решения}
Давайте обусловимся, что чтобы посчитать значение в вершине, надо взять сумму значений всех вершин в поддереве. Тогда можно свести запрос прибавления на пути $\texttt{add-on-path(v, u, x)}$ - прибавить \texttt{x} всем вершинам на пути от \texttt{v} до \texttt{u}, к следующим операциям :
\begin{itemize}
\item \texttt{val[v] += x}
\item \texttt{val[u] += x}
\item \texttt{val[lca(u, v)] -= x}
\item \texttt{val[parent(lca(u, v))] -= x}
\end{itemize}
Теперь давайте поймём почему это действительно то что мы хотим.
\begin{itemize}
\item[(1)] Рассмотрим вершину на пути от \texttt{u} до \texttt{v} кроме их \texttt{lca}. Для всех таких вершин сумма в поддереве увеличилась на \texttt{x}.
\item[(2)] Рассмотрим \texttt{lca(v, u)}. Сумма в поддереве изменилась так : $(was + x + x - x) = was + x$. Сумма в поддереве увеличилась на \texttt{x}.
\item[(3)] Рассмотрим вершину, не принадлежащую пути от \texttt{v} до \texttt{u}. 

Если она находится выше их \texttt{lca}, то сумма в поддереве не изменится, так $(was + x + x - x - x) = was$.

Если она находится ниже, т.е либо ниже вершины \texttt{v} либо ниже  вершины \texttt{v}, то для нее в поддереве ничего не изменилось
\end{itemize}
\textbf{Тогда алгоритм действий будет следующий:} 
\begin{itemize}
\item Выпишем эйлеров обход, но немного упрощенный, запустимся dfs-ом из корня, когда зашли в какую-то вершину, сразу выпишем её в вектор. И для каждой вершины запомним какой отрезок отвечает за ее поддерево.
\item Посчитаем двоичные подъёмы за $\mathcal{O}(n\log(n))$, чтобы мы могли вычислять $lca$ за $\mathcal{O}(\log(n))$
\item Построим дерево отрезков на сумму на массиве значений в вершинах, выписанных в указанном выше порядке.
\item Когда приходит запрос прибавления на пути, делаем прибавление деревом отрезков в 4-х точках :

$val[v] \texttt{+= } x$, 

$val[u] \texttt{+= } x$, 

$val[lca(v, u)] \texttt{-= } x $, 

$val[parent(lca(v, u))] \texttt{-= } x$


= $\mathcal{O}(\log(n))$ операций.
\item Когда приходит запрос значения в вершине, берем сумму на отрезке, соответствующему поддереву этой вершины деревом отрезков за $\mathcal{O}(\log(n))$.
\end{itemize}
\end{document}