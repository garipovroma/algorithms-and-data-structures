\documentclass{article}

\usepackage[utf8]{inputenc} 
\usepackage[russian]{babel}
\usepackage{amsmath,amssymb}
\usepackage{tipa}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage{alltt}
\binoppenalty=10000
\relpenalty=10000
\title{Алгоритмы и Структуры Данных ДЗ-3}
\date{08.06.2020}
\usepackage{multicol}
\usepackage[left=2cm,right=2cm,
    top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}


\author{Гарипов Роман М3138}

\begin{document}


  \pagenumbering{gobble} 
  \maketitle
  \pagenumbering{arabic}
\section*{Задача \textnumero 1}
\subsection*{Для начала научимся прибавлять константу на всём отрезке}
Такая задача была в лабораторной. Будем работать с массивом \texttt{d\_a[i] = a[i] - a[i - 1]}. Чтобы прибавить на отрезке $[l;r]$ значение $x$ надо сделать два изменения массива :
\begin{itemize}
\item \texttt{d\_a[l] += x}
\item \texttt{d\_a[r + 1] -= x}
\end{itemize}
Обработав все запросы, можно вычислить исходный массив с выполнеными операциями на отрезках так : посчитать префиксную сумму на массиве \texttt{d\_a}. 
\subsection*{Переходим к прибавлению прогрессии на отрезке}
Для арифметической прогрессии характерно то, что разность соседних элементов это какая-то константа \texttt{k}, поэтому логично будет завести массив разностей массива разностей, так называемый массив \texttt{d\_d\_a[i]}.
Тогда запросу прибавления прогрессии \texttt{(k, x, l, r)} будут соотвествовать следующие изменения массива :
\begin{itemize}
\item \texttt{d\_d\_a[l] += x};

 \texttt{d\_d\_a[l + 1] += x};
 
\item \texttt{d\_d\_a[l + 1] += k};

\texttt{d\_d\_a[r + 1] -= k};

\item  \texttt{d\_d\_a[r + 1] -= (x + k $\cdot$ (len - 1))};

\texttt{d\_d\_a[r + 2] += (x + k $\cdot$ (len - 1))};
\end{itemize}
Мы явно сделали изменения в массиве в тех местах, в которых разность разностей соседних элементов поменялась.
Чтобы найти итоговую последовательность, надо дважды посчитать массив префиксных сумм массива \texttt{d\_d\_a[i]}, потом посчитать префикс суммы на этом массиве префикс сумм, т е проще говоря дважды посчитать префикс суммы. Так как по условию задачи массив изначально проинициализован числами \texttt{a[i]}, нужно сложить соотвествущие элементы двух массивов чтобы получить ответ на задачу.
\section*{Задача \textnumero 4}
Посчитаем двоичные подъемы, чтобы уметь искать \texttt{lca} двух вершин. Так же построим \texttt{heavy-light декомпозицию}, в которой для каждого пути будем хранить дерево отрезков, в котором будем хранить самую левую и самую правую непомеченную вершину на нём(не думаю что стоит много говорить о том как это делать : искать минимум и его позицию на отрезке, массив будет состоять из 0 и 1 - непомеченные и помеченные вершины).\newpage

\textbf{Запрос - пометить вершину \texttt{v}}

\begin{itemize}

\item Возьмём путь на котором лежит вершина \texttt{v}.

 Сделаем запрос присвоения $1$ в точке соответствующей вершине \texttt{v} в ДО на этом пути.
\end{itemize}


\textbf{Запрос - найти самого нижнего непомеченного общего предка для  \texttt{u} и \texttt{v}}

\begin{itemize}

\item Найдём \texttt{lca(u, v)} = x используя двоичные подъёмы.
\item Теперь будем подниматься по путям нашей декомпозиции от вершины \texttt{x}. 

Поднимаясь от $x$ до корня нашего дерева, мы обеспечим то, что ответ на запрос будет какой-то общий предок вершин \texttt{u} и \texttt{v}.
\item Находясь на очередном пути, надо понять есть ли на нём хотя бы одна непомеченная вершина. Возьмем позицию минимума на этом пути в корне дерева отрезков, если эта вершина выше чем вершина \texttt{x} то на этом пути есть хотя бы одна непомеченная вершина которая является общим предком вершин \texttt{v} и \texttt{u}. Будем подниматься по декомпозиции до тех пор, пока не найдем такой путь.
\item Когда нашли такой путь, запросим у дерева отрезков самый правый минимум на префиксе нашего пути от головы пути до вершины на которой сейчас стоим. 

\end{itemize}
\textbf{Итого : }
Предпосчёт за $\mathcal{O}(n\log(n))$, ответ на запрос за $\mathcal{O}(\log(n))$, т.к первый запрос это просто присвоение в дереве отрезков, второй запрос - подняться по декомпозиции - не более $\mathcal{O}(\log(n))$ + один запрос в дереве отрезков - $\mathcal{O}(\log(n))$

\noindent\rule{\textwidth}{0.5pt}
Можно избавиться от двоичных подъёмов и искать \texttt{lca} подъёмом по декомпозии, это так же будет работать за $\mathcal{O}(\log(n))$, но предпосчёт будет занимать $\mathcal{O}(n)$ времени.
\section*{Задача \textnumero 5}
Аналогично задаче \textnumero 4, для запроса снятия отметки с вершины надо будет присваивать 0 в точке.
\end{document}