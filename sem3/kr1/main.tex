    \documentclass{article}

\usepackage[utf8]{inputenc} 
\usepackage[russian]{babel}
\usepackage{amsmath,amssymb}
\usepackage{tipa}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage{alltt}
\usepackage[usenames,dvipsnames]{color}
\usepackage[hidelinks]{hyperref}
\usepackage{amsthm}
\usepackage{multicol}
\usepackage[left=2cm,right=2cm,
    top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\binoppenalty=10000
\relpenalty=10000
\definecolor{myblue}{RGB}{0, 0, 255}
\title{Алгоритмы и Структуры Данных \Large{\href{https://nerc.itmo.ru/teaching/algo/year2019/quiz-05/d576180f2ecf1d65401da8ffbe7b8726.pdf}{\textcolor{myblue}{КР1 Вариант 07}}}}
\date{05.11.2020}

\newtheorem{lemma}{Лемма}

\author{Гарипов Роман М3238}

\newcommand{\complexity}[1]{$\mathcal{O}(#1)$}

\begin{document}
  \pagenumbering{gobble} 
  \maketitle
  \pagenumbering{arabic}
\section*{Задача \textnumero 1}
\subsection*{Алгоритм}
    \begin{enumerate}
        \item Запустим алгоритм Форда-Беллмана, вычислим массив $d[i]$ - длина кратчайшего пути от вершины $s$ до вершины $i$%,оно всегда будет существовать потому что граф не содержит отрицательных циклов
        \item Далее будем работать на графе, ребра которого - ребра исходного графа лежащие на кратчайших путях, то есть добавим ребро в граф $(uv)$, если $d[u] + e_{uv} = d[v]$. В таком графе могут быть только циклы веса ноль.
        \item Сконденсируем граф, чтобы циклы весом ноль сжались в отдельные вершины, будем называть такие вершины помеченными. Те вершины в сконденсированном графе, которые были обычными вершинами в исходном назовём -- непомеченными.
        \item Для всех помеченных вершин, запустим из них \texttt{dfs} и запишем в массиве ответов, что для всех вершин достижимых из текущей помеченной, кратчайший путь не единственный(если достигли помеченной вершины, то понятно что надо записать все вершины которые находятся в этой компоненте сильной связности и саму компоненту сильной связности из которой стартуем \texttt{dfs}-ом тоже надо записать). 
        \item Осталось обработать вершины, которые недостижимы из помеченных. Для каждой такой вершины $x$ будем запускать \texttt{dfs} по обратным рёбрам(грубо говоря будем подниматься вверх по графу) и смотреть, если из какой-то вершины можно пойти в две какие-то, то для вершины $x$ запишем, что кратчайший путь не единственный.
    \end{enumerate}
    Ассимптотика первого пункта -- \complexity{VE}, пятого -- \complexity{V(V + E)} = \complexity{VE}, остальные пункты -- \complexity{V + E}.
    \subsection*{Доказательство}
    \begin{enumerate}
        \item Будем считать, что из стартовой вершины существуют пути во все остальные вершины графа. Понятно что для тех, для которых не существует пути, не будет существовать ни одного кратчайшего. Для всех остальных вершин кратчайшее расстоние будет существовать. 
        \item Доказательство корректности построения графа кратчайших путей будет показано в Задаче \textnumero 2, где будет строится такой же граф кратчайших путей на неориентированном невзвешанном графе, но такое же доказательство пройдет и для нашего случая.
        \item Действительно, в таком графе могут быть циклы только веса ноль, так как отрицательных нет по условию, а цикл положительного веса  не может существовать в графе кратчайших путей.
        \item Можем покрутиться $n$ раз по циклу веса 0 и пойти дальше, и покрутиться $n + 1$ раз по циклу веса 0, это будут разные пути, а поскольку мы работаем в графе кратчайших путей -- это будут разные кратчайшие пути. Таким образом покроем все случаи, когда до вершины есть несколько кратчайших путей проходящих по циклу веса 0. Осталось обработать все случаи когда цикла на пути не будет, это и говорит нам о корректности алгоритма, так как обработаны все возможные циклы.
        \item Рассмотрим случай, когда по обратному ребру из какой-то вершины $x$ можем пойти в две или более вершины, а \texttt{dfs} по обратным рёбрам запущен из вершины $y$. Существует два или более пути $s \rightsquigarrow x$, так же существует $x \rightsquigarrow y$. Ну тогда существует и два или более путей $s \rightsquigarrow y$. Наш \texttt{dfs} ищет ``развилки'' в графе. И он всегда их найдёт, ведь если по пути от вершины $s$ существует развилка и там хотя бы два пути, которые потом встречаются(до остальных просто будет существовать единственный путь, если до этого не была обнаружена неединственность), то в какую-то вершину входит два или более ребра.
    \end{enumerate}
\section*{Задача \textnumero 2}
    Решение с ассимптотикой \complexity{E + V}.
    \begin{itemize}
        \item[(a)] 
        Запустим \texttt{bfs} в нашем графе и выделим все кратчайшие пути.
        \subsubsection*{Алгоритм}
        \begin{enumerate}
            \item Предварительно запустим \texttt{bfs} на нашем графе, чтобы посчитать массив расстоний $d[i]$.
            \item Далее запустим обход с очередью от вершины $t$, достанем очередную вершину $u$ из очереди, пройдемся по её соседям $v$, если $d[u] = d[v] + e_{vu}$, то добавим ребро $(vu)$ в граф кратчайших путей, а вершину $v$ в очередь. Так мы добавим в граф все рёбра которые лежат хотя бы на одном кратчайшем пути и пройдя по ним можно достичь вершины $t$.  
        \end{enumerate}
         
        \subsubsection*{Доказательство}
        Рассмотрим момент, когда добавляем ребро $(vu)$. Покажем, что это ребро лежит на кратчайшем пути от $s$ до $u$, если выполняется описанное условие.
        $d[u]$ - длина кратчайшего пути до вершины $u$.
        Пусть путь с ребром $(vu)$ на конце -- не кратчайший. Тогда 	$\exists v' \in V : d[v'] + e_{v'u} < d[v] + e_{vu} = d[u]$, получаем противоречие, ведь $d[u]$ -- кратчайший.
        Взяли произволное ребро $(vu)$, значит для всех рёбер это будет справедливо.
        \item[(b)] Теперь понадобится модифицированный \texttt{bfs}. \newline
        \subsubsection*{Алгоритм}
        \begin{enumerate}
            \item Будем поддерживать очередь $Q$ с таким инвариатом : $$\forall v \in Q \mbox{ } \exists \mbox{ путь }s \rightsquigarrow v = way : way \mbox { -- префикс минимального лексикографически пути } s \rightsquigarrow t$$ причем все вершины в очереди находятся на одинаковом расстоянии от вершины $s$ (так будет проще доказывать корректность).
                \item Положим в очередь вершину $s$.  Запустим \texttt{bfs} по графу кратчайших путей, но немного изменим условие добавления новой вершины в очередь, а так же будем работать с двумя очередями, одна - текущий слой, а вторая - следующий слой, в которые ещё добавляем соседей вершин из текущего. 
                    \item Формально, будем делать так: рассматриваем вершину $x$ которую достали из очереди в цикле \texttt{bfs'a}. Пусть $min\_value = \min \limits_{xy \in E}xy_{cost}$, где $xy_{cost}$ -- число написанное на этом ребре. В очередь соответствующую новому слою, добавим всех соседей всех вершин из текущего слоя, если мы не были в очередном соседе, а так же число написанное на ребре в соседа -- $xy_{cost}$.
                    \item Когда очередь с вершинами из текущего слоя станет пустой, применим операцию swap для текущей пустой очереди и очереди следующего слоя.
        \end{enumerate}
        \subsubsection*{Доказательство}
        Стоит сказать, что, когда мы используем две очереди в нашем \texttt{bfs'e} по сути ничем не отличается от использования одной в обычной версии алгоритма, потому что по прежнему все вершины будут посещены в порядке неубывания расстояния от стартовой вершины. 
        
        Так будет удобнее доказывать корректность алгоритма, потому что тогда можем посмотреть на последовательность очередей, $i$-ая очередь соотвествует вершинам в графе по пути до которых мы получаем префикс оптимального ответа длины $i$. 
        
        Достаточно доказать что при корректно сформированном текущем слое($i$ -ый слой), мы наберём новый слой который будет содержать вершины -- путь до которых будет являться оптимальным префиксом длины $i + 1$
        
        Получаем доказательство по индукции.
        
        \textbf{База:} $0$-ой слой, имеем пустой префикс, который является оптимальным.
        
        \textbf{Переход:} Минимизоровав префикс(что уже имеем по предположению индукции) и добавив минимально возможный символ получим минимальный префикс длины $i + 1$, обозначим его за $pref_{i + 1}$. Пусть не так. Предположим существует префикс $pref'_{i + 1}$ меньше нашего лексикографически. Он не может отличаться в одном из первых $i$ символов, потому что тогда он не меньше $pref_{i + 1}$. Тогда только в $i + 1$ позиции. Но в $pref_{i + 1}$ стоит минимальный символ из всех возможных, поэтому $pref'_{i + 1}$ -- не будет минимальным, противоречие.
        
        Значит $pref_{i + 1}$ -- так выглядят все префиксы длины $i + 1$, как раз все такие мы и добавим в очередь для следующего слоя. 
        
        Поскольку наш обход запускается на графе кратчайших путей, мы выберем минимальный префикс , что нас и просили.
            
    \end{itemize}
\section*{Задача \textnumero 3}
    Обозначим за $X$ -- правую долю, за $Y$ -- левую. Знаком равностильности $\Leftrightarrow$ будем обозначать равносильность максимизации двух выражений.
    $$ |A| - |F(A)| \Leftrightarrow |A| - |F(A)| + |X| - |X| \Leftrightarrow |A| + |X \setminus f(A)| - |X| \Leftrightarrow |A| + |X \setminus f(A)| $$
    Последнее преобразование справедливо, так как $|X|$ -- фиксированная величина, которая не зависит от выбора $A$.
    
    Последнее выражение описывает размер независимого множества, действительно, выбрали какие-то вершины в левой доле, взяли всех кроме соседей выбранных вершин в правой доле. Это соотвествует оптимальному набору вершин при фиксированном множестве $A$. Тогда понятно, что максимизировав это значение, получим максимальное независимое множество. Поскольку имееют место указанные равносильные преобразования при максимизации, значение $|A| - |F(A)|$  -- максимально, когда в качестве $A$ выбираются все вершины левой доли, лежащие в максимальном независимом множестве.
\section*{Задача \textnumero 4}
Решение c ассимптотикой \complexity{E + V}.
    \newline
    \newline
    Будем считать что имеем дело со связным графом, на случай несвязных графов алгоритм и доказательство обобщаются без особых проблем.
    \begin{lemma}
        Если каждую компоненту рёберной двусвязносьти в графе сжать в отдельную вершину, то получим дерево.
        %Если каждую компоненту рёберной двусвязности в вершинном кактусе сжать в 1 вершину, то получим дерево.
    \end{lemma}%fix-lemma
    \begin{proof}
        %Пусть не так. Тогда в сжатом графе есть циклы. 
        %Рассмотрим два случая: он связывает вершины, каждая из которых является обычной вершиной исходного графа, связывает вершины, некоторых из которых являются сжатым циклом. Первого быть не может, потому что такой цикл сжался бы в одну вершину, в которую не входят рёбра. Второго тоже, ведь тогда взяв произвольную вершину $V$ которая является сжатым циклом и вершину $x \in V$, можем выделить два цикла, которым она принадлежит - один сжатый цикл, другой - циклический обход графа сжатых вершин. Противоречие определению вершинного кактуса. Следовательно циклов быть не может, значит имеем связный граф без циклов -- дерево.
        Действительно, пусть не так. Тогда имеем в сжатом графе цикл. Поскольку какие-то вершины образуют цикл, они должны быть в одной компоненте рёберной двусвязности. Но мы уже сжали их, и эти вершины оказались в разных. Противоречие.
    \end{proof}
    Эта лемма говорит нам о том, что можно рассматривать компоненты рёберной двусвязности по отдельности, так как циклов соединяющих две разные компоненты не может быть.
    \begin{lemma}
        Компонента рёберной двусвязности является рёберным кактусом $\Leftrightarrow$ в компоненте не более одного цикл.
    \end{lemma}
    \begin{proof}
      % Докажем первое утверждение. Пусть в компоненте два цикла. Они всегда пересекаются хотя бы по одной вершине, потому что если не будут пересекаться, то они либо связаны ребром, либо не связаны, в обоих случаях они бы не были в одной компоненте вершинной двусвязности. Возьмем вершину из пересечения. Она лежит на двух циклах, определение вершинного кактуса не выполняется.
        ($\Rightarrow$)
        Если компонента -- вершинный кактус, она будет содержать не более одного цикла. Пусть их два или более. Возьмём любые два. Пусть они не пересекаются, тогда эти два цикла либо связаны ребром, либо нет, в обоих случаях они были бы в разных компонента рёберной двусвязности. Значит они пересекаются хотя бы по одному вершине. Возьмём эту вершину, она принадлежит двум циклам, по определению вершинного кактуса такого быть не может. Противоречение. Значит больше одного быть не может.
        
        ($\Leftarrow$) Имеем не более одного цикла в компоненте, все вершины в одной компоненте, значит только этому единственному циклу и принадлежит каждая вершина, либо не принадлежать никакому -- определение выполняется.
    \end{proof}
    Лемма 2 -- критерий для проверки компоненты на "вершинную кактусовость". Лемма 1 -- говорит что можно проверять компоненты по отдельности. Получаем алгоритм который позволяет является ли граф вершинным кактусом.
    
    Сожмём вершины рёберной двусвязности в отдельные вершины за \complexity{E + V} операций. Проверим что в каждой ровно один цикл(степень каждой вершины должна равняться двум) за \complexity{E + V}. 
    
    В случае несвязного графа надо проверить то же самое в каждой компоненте по отдельности.
\section*{Задача \textnumero 5}
    Решение с ассимптотикой \complexity{E + V^{4}}
    \subsection*{Алгоритм} 
    \begin{enumerate}
        \item Сожмём кратные рёбра минимального веса между всеми парами вершин и запоминим сколько таких рёбер с минимальным весом существует между каждой фиксированной парой вершин.
        \item Запустим Алгоритм Флойда, найдем кратчайшее расстояние от каждой вершины до любой другой за \complexity{V^{3}}
        \item Переберём пару вершин $u$ и $v$, между которых хотим посчитать количество рёбер лежащих хотя бы на одном кратчайшем пути $u \rightsquigarrow v$. Перерём пару вершин $x$ и $y$, между которыми возьмём все рёбра минимального веса. Если $d[u][x] + xy_{cost} + d[y][v] = d[u][v]$, то прибавим к ответу $ans[u][v]$ количество ребёр минимального веса ведущих из вершины $x$ в вершину $y$.
    \end{enumerate}
    Таким образом, получили матрицу, в которой записан ответ для каждой пары вершин.
    \subsection*{Доказательство}
    Покажем корректность 3-го пункта. Конкретно, покажем, что наш критерий для принадлежности ребру кратчайшему пути $u \rightsquigarrow v$ правильный. В Задаче \textnumero 2 мы показали, что если при переходе по ребру кратчайший путь увеличивается на стоимость его ребра, то ребро принадлежит какому-то кратчайшему пути. Точно такое же доказательство будет работать и для нескольких последовательных рёбер. Ведь можно представить что мы сначала добавили к пути $d[u][x]$ ребро $xy$, а потом к получившемуся пути - путь $y \rightsquigarrow v$ Поэтому предложенный критерий является корректным.
\end{document}